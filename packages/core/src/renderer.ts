import path from "node:path";

import { hasProperty } from "@graphql-markdown/utils/object";
import { toSlug, startCase } from "@graphql-markdown/utils/string";
import { pathUrl } from "@graphql-markdown/utils/url";
import { hasDirective } from "@graphql-markdown/utils/graphql";
import {
  prettifyJavascript,
  prettifyMarkdown,
} from "@graphql-markdown/utils/prettier";
import {
  saveFile,
  ensureDir,
  copyFile,
  readFile,
  fileExists,
} from "@graphql-markdown/utils/fs";

import { ASSETS_LOCATION } from "./config";
import { DocOptions, IPrinter } from "./type";
import { GraphQLNamedType } from "graphql/type/definition";
import { Maybe } from "graphql/jsutils/Maybe";
import { ObjMap } from "graphql/jsutils/ObjMap";
const { schemaSidebar } = require(`${ASSETS_LOCATION}/sidebar.json`);

const SIDEBAR = "sidebar-schema.js";
const HOMEPAGE_ID = "schema";
const CATEGORY_YAML = "_category_.yml";

export default class {
  readonly printer: IPrinter;
  readonly outputDir: string;
  readonly baseURL: string;
  readonly group: any;
  readonly prettify: boolean;
  readonly options: DocOptions;
  readonly skipDocDirective: string | undefined;

  constructor(
    printer: IPrinter,
    outputDir: string,
    baseURL: string,
    group: any,
    prettify: boolean,
    docOptions: DocOptions,
    skipDocDirective: string | undefined
  ) {
    this.group = group;
    this.outputDir = outputDir;
    this.baseURL = baseURL;
    this.printer = printer;
    this.prettify = prettify;
    this.options = docOptions;
    this.skipDocDirective = skipDocDirective;
  }

  async generateCategoryMetafile(
    category: string,
    dirPath: string
  ): Promise<void> {
    const filePath = path.join(dirPath, CATEGORY_YAML);

    const metafileExists = await fileExists(filePath);
    if (metafileExists) {
      return;
    }

    await ensureDir(dirPath);

    const label = startCase(category);
    const link =
      typeof this.options === "undefined" || !this.options.index
        ? "null"
        : `\n  type: generated-index\n  title: '${label} overview'\n`;

    await saveFile(filePath, `label: ${label}\nlink: ${link}\n`);
  }

  async renderRootTypes(rootTypeName: string, type: Maybe<ObjMap<unknown>>) {
    if (typeof type !== "object" || type === null) {
      return undefined;
    }

    return Promise.all(
      Object.keys(type)
        .map(async (name) => {
          let dirPath = this.outputDir;

          if (hasProperty(this.group, name)) {
            dirPath = path.join(dirPath, toSlug(this.group[name]));
            await this.generateCategoryMetafile(this.group[name], dirPath);
          }

          dirPath = path.join(dirPath, toSlug(rootTypeName));
          await this.generateCategoryMetafile(rootTypeName, dirPath);

          return this.renderTypeEntities(dirPath, name, (type as any)[name]);
        })
        .filter((res) => typeof res !== "undefined")
    );
  }

  async renderTypeEntities(
    dirPath: string,
    name: string,
    type: GraphQLNamedType
  ) {
    if (
      typeof type === "undefined" ||
      type === null ||
      this.skipDocDirective && hasDirective(type, this.skipDocDirective)
    ) {
      return undefined;
    }

    const fileName = toSlug(name);
    const filePath = path.join(path.normalize(dirPath), `${fileName}.mdx`);

    const content = this.printer.printType(fileName, type, this.options);
    const prettified = await (this.prettify ? prettifyMarkdown(content) : content);
    await saveFile(
      filePath,
      prettified
    );

    const pagePath = path.relative(this.outputDir, filePath);
    const groups = pagePath.match(
      /(?<category>[A-Za-z0-9-]+)[\\/]+(?<pageId>[A-Za-z0-9-]+).mdx?$/
    )?.groups;

    if (typeof groups === "undefined"  ||  groups === null) {
      return undefined;
    }
    
    const slug = pathUrl.join(groups['category'], groups['pageId']);
  
    return { category: startCase(groups['category']), slug: slug };
  }

  async renderSidebar(): Promise<string> {
    const sidebar = {
      schemaSidebar: schemaSidebar.map((entry: any) => {
        switch (entry.type) {
          case "doc":
            entry.id = pathUrl.join(this.baseURL, HOMEPAGE_ID);
            break;
          case "autogenerated":
            entry.dirName = this.baseURL;
            break;
          default: //do nothing
        }
        return entry;
      }),
    };

    const jsonSidebar = `
/** @type {import('@docusaurus/plugin-content-docs').SidebarsConfig} */

module.exports = ${JSON.stringify(sidebar, null, 2)};
`;

    const filePath = path.join(this.outputDir, SIDEBAR);
    const content  = await (this.prettify ? prettifyJavascript(jsonSidebar) : jsonSidebar);
    await saveFile(
      filePath,
      content
    );

    return path.relative("./", filePath);
  }

  async renderHomepage(homepageLocation: string): Promise<void> {
    const homePage = path.basename(homepageLocation);
    const destLocation = path.join(this.outputDir, homePage);
    const slug = pathUrl.resolve("/", this.baseURL);

    await copyFile(homepageLocation, destLocation);

    const template = await readFile(destLocation);

    const data = template
      .toString()
      .replace(/##baseURL##/gm, slug)
      .replace(/##generated-date-time##/gm, new Date().toLocaleString());
    await saveFile(destLocation, data);
  }
}
